commit 60fca03923b5393a2c5a69fa7314d955757d4cd5
Author: lixingcong <lixingcong@live.com>
Date:   2024-12-03 10:43:32 +0800

    add xor cipher

diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 9ca9d85..09a417d 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -65,6 +65,7 @@ set(SS_SERVER_SOURCE
         cache.c
         resolv.c
         server.c
+		crypto-xor.c
         ${SS_CRYPTO_SOURCE}
         ${SS_PLUGIN_SOURCE}
         ${SS_ACL_SOURCE}
diff --git a/src/Makefile.am b/src/Makefile.am
index c255b60..ffacc48 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -31,6 +31,7 @@ crypto_src = crypto.c \
              aead.c \
              stream.c \
              ppbloom.c \
+			crypto-xor.c \
              base64.c
 
 plugin_src = plugin.c
@@ -109,7 +110,7 @@ libshadowsocks_libev_la_LDFLAGS = -version-info $(VERSION_INFO)
 libshadowsocks_libev_la_LIBADD = $(ss_local_LDADD)
 include_HEADERS = shadowsocks.h
 
-noinst_HEADERS = acl.h crypto.h stream.h aead.h json.h netutils.h redir.h server.h uthash.h \
+noinst_HEADERS = acl.h crypto.h crypto-xor.h stream.h aead.h json.h netutils.h redir.h server.h uthash.h \
                  cache.h local.h plugin.h resolv.h tunnel.h utils.h base64.h ppbloom.h \
                  common.h jconf.h manager.h rule.h socks5.h udprelay.h winsock.h
 EXTRA_DIST = ss-nat
diff --git a/src/common.h b/src/common.h
index 66e985c..a38ab95 100644
--- a/src/common.h
+++ b/src/common.h
@@ -31,6 +31,9 @@
 #endif
 
 #include "crypto.h"
+#ifdef MODULE_TUNNEL
+#include "netutils.h"
+#endif
 
 int init_udprelay(const char *server_host, const char *server_port,
 #ifdef MODULE_LOCAL
diff --git a/src/crypto-xor.c b/src/crypto-xor.c
new file mode 100644
index 0000000..464661f
--- /dev/null
+++ b/src/crypto-xor.c
@@ -0,0 +1,230 @@
+/*
+ * stream.c - Manage stream ciphers
+ *
+ * Copyright (C) 2013 - 2019, Max Lv <max.c.lv@gmail.com>
+ *
+ * This file is part of the shadowsocks-libev.
+ *
+ * shadowsocks-libev is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * shadowsocks-libev is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with shadowsocks-libev; see the file COPYING. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#include "crypto-xor.h"
+#include "common.h"
+#include "jhash.h"
+#include "utils.h"
+#include <string.h>
+//#include <assert.h>
+
+#define XOR_KEY_SIZE 32
+#define XOR_NONCE_SIZE 4
+
+/* An arbitrary initial parameter */
+#define JHASH_INITVAL 0xdeadbeef
+
+static inline void xor_impl(const void* in, void* out, size_t dataLen, const uint8_t* key, size_t keyLen)
+{
+	size_t               i    = 0;
+	const unsigned char* pIn  = in;
+	unsigned char*       pOut = out;
+	for (; i < dataLen; ++i)
+		*(pOut++) = *(pIn++) ^ key[i % keyLen];
+}
+
+static inline void xor_cipher_impl(const void* in, void* out, size_t dataLen, const cipher_ctx_t* ctx)
+{
+	const cipher_t* cipher = ctx->cipher;
+	xor_impl(in, out, dataLen, cipher->key, cipher->key_len);
+	xor_impl(out, out, dataLen, ctx->nonce, cipher->nonce_len);
+}
+
+void xor_ctx_release(cipher_ctx_t *cipher_ctx)
+{
+	if (cipher_ctx->chunk != NULL) {
+		bfree(cipher_ctx->chunk);
+		ss_free(cipher_ctx->chunk);
+		cipher_ctx->chunk = NULL;
+	}
+}
+
+int xor_encrypt_all(buffer_t *plaintext, cipher_t *cipher, size_t capacity)
+{
+	cipher_ctx_t cipher_ctx;
+	xor_ctx_init(cipher, &cipher_ctx, 1);
+
+	static buffer_t tmp = {0, 0, 0, NULL}; // static
+
+	const size_t nonce_len = cipher->nonce_len;
+	const size_t data_len  = plaintext->len;
+
+	brealloc(&tmp, nonce_len + data_len, capacity);
+	buffer_t* ciphertext = &tmp;
+	ciphertext->len      = nonce_len + data_len;
+
+	memcpy(ciphertext->data, cipher_ctx.nonce, nonce_len);
+	xor_cipher_impl(plaintext->data, ciphertext->data + nonce_len, data_len, &cipher_ctx);
+	xor_ctx_release(&cipher_ctx);
+
+	brealloc(plaintext, ciphertext->len, capacity);
+	memcpy(plaintext->data, ciphertext->data, ciphertext->len);
+	plaintext->len = ciphertext->len;
+
+	return CRYPTO_OK;
+}
+
+int xor_encrypt(buffer_t *plaintext, cipher_ctx_t *cipher_ctx, size_t capacity)
+{
+	if (!cipher_ctx)
+		return CRYPTO_ERROR;
+
+	static buffer_t tmp = {0, 0, 0, NULL};
+
+	size_t nonce_len = 0;
+	if (!cipher_ctx->init) {
+		nonce_len = cipher_ctx->cipher->nonce_len;
+	}
+
+	const size_t data_len   = plaintext->len;
+	brealloc(&tmp, nonce_len + data_len, capacity);
+	buffer_t*    ciphertext = &tmp;
+	ciphertext->len         = nonce_len + data_len;
+
+	if (!cipher_ctx->init) {
+		memcpy(ciphertext->data, cipher_ctx->nonce, nonce_len);
+		cipher_ctx->init    = 1;
+	}
+
+	xor_cipher_impl(plaintext->data, ciphertext->data + nonce_len, data_len, cipher_ctx);
+
+	brealloc(plaintext, ciphertext->len, capacity);
+	memcpy(plaintext->data, ciphertext->data, ciphertext->len);
+	plaintext->len = ciphertext->len;
+
+	return CRYPTO_OK;
+}
+
+int xor_decrypt_all(buffer_t *ciphertext, cipher_t *cipher, size_t capacity)
+{
+	const size_t nonce_len = cipher->nonce_len;
+
+	if (ciphertext->len <= nonce_len)
+		return CRYPTO_ERROR;
+
+	cipher_ctx_t cipher_ctx;
+	xor_ctx_init(cipher, &cipher_ctx, 0);
+	memcpy(cipher_ctx.nonce, ciphertext->data, nonce_len);
+
+	static buffer_t tmp = { 0, 0, 0, NULL };
+	brealloc(&tmp, ciphertext->len, capacity);
+	buffer_t *plaintext = &tmp;
+	plaintext->len = ciphertext->len - nonce_len;
+
+	xor_cipher_impl(ciphertext->data + nonce_len, plaintext->data, plaintext->len, &cipher_ctx);
+	xor_ctx_release(&cipher_ctx);
+
+	brealloc(ciphertext, plaintext->len, capacity);
+	memcpy(ciphertext->data, plaintext->data, plaintext->len);
+	ciphertext->len = plaintext->len;
+
+	return CRYPTO_OK;
+}
+
+int xor_decrypt(buffer_t *ciphertext, cipher_ctx_t *cipher_ctx, size_t capacity)
+{
+	if (!cipher_ctx)
+		return CRYPTO_ERROR;
+
+	cipher_t* cipher = cipher_ctx->cipher;
+
+	static buffer_t tmp = {0, 0, 0, NULL};
+	brealloc(&tmp, ciphertext->len, capacity);
+	buffer_t* plaintext = &tmp;
+	plaintext->len      = ciphertext->len;
+
+	if (!cipher_ctx->init) {
+		if (!cipher_ctx->chunk) {
+			cipher_ctx->chunk = (buffer_t*) ss_malloc(sizeof(buffer_t));
+			memset(cipher_ctx->chunk, 0, sizeof(buffer_t));
+			balloc(cipher_ctx->chunk, cipher->nonce_len);
+		}
+
+		const size_t left_len = min(cipher->nonce_len - cipher_ctx->chunk->len, ciphertext->len);
+		if (left_len > 0) {
+			memcpy(cipher_ctx->chunk->data + cipher_ctx->chunk->len, ciphertext->data, left_len);
+			memmove(ciphertext->data, ciphertext->data + left_len, ciphertext->len - left_len);
+			cipher_ctx->chunk->len += left_len;
+			ciphertext->len -= left_len;
+		}
+
+		if (cipher_ctx->chunk->len < cipher->nonce_len)
+			return CRYPTO_NEED_MORE;
+
+		plaintext->len -= left_len;
+
+		memcpy(cipher_ctx->nonce, cipher_ctx->chunk->data, cipher->nonce_len);
+		cipher_ctx->init = 1;
+	}
+
+	if (ciphertext->len <= 0)
+		return CRYPTO_NEED_MORE;
+
+	xor_cipher_impl(ciphertext->data, plaintext->data, ciphertext->len, cipher_ctx);
+
+	brealloc(ciphertext, plaintext->len, capacity);
+	memcpy(ciphertext->data, plaintext->data, plaintext->len);
+	ciphertext->len = plaintext->len;
+
+	return CRYPTO_OK;
+}
+
+void xor_ctx_init(cipher_t* cipher, cipher_ctx_t* cipher_ctx, int enc)
+{
+	memset(cipher_ctx, 0, sizeof(cipher_ctx_t));
+	cipher_ctx->cipher = cipher;
+
+	if (enc) {
+		rand_bytes(cipher_ctx->nonce, cipher->nonce_len);
+	}
+}
+
+cipher_t* xor_init(const char* pass, const char* /*key*/, const char* /*method*/)
+{
+	if (!pass || 0 == *pass)
+		return NULL;
+
+	cipher_t* cipher = (cipher_t*) ss_malloc(sizeof(cipher_t));
+	memset(cipher, 0, sizeof(cipher_t));
+
+	cipher->key_len   = XOR_KEY_SIZE;
+	cipher->nonce_len = XOR_NONCE_SIZE;
+
+	{
+		// init the xor key
+		uint32_t       loopCount      = cipher->key_len / sizeof(uint32_t);
+		uint32_t*      pOut32         = (uint32_t*)&cipher->key[0];
+		uint32_t       hashVal        = JHASH_INITVAL;
+		const uint32_t passwordLength = min(strlen(pass), cipher->key_len);
+
+		memset(cipher->key, 0xff, sizeof(cipher->key));
+		memcpy(cipher->key, pass, passwordLength);
+
+		while (loopCount--) {
+			*pOut32 = jhash_1word(*pOut32, hashVal);
+			++pOut32;
+			++hashVal;
+		}
+	}
+
+	return cipher;
+}
diff --git a/src/crypto-xor.h b/src/crypto-xor.h
new file mode 100644
index 0000000..29e206d
--- /dev/null
+++ b/src/crypto-xor.h
@@ -0,0 +1,27 @@
+/*
+ * crypto.h
+ *
+ * FIXME: 功能简要概述
+ *
+ * Created on: 2024年 12月 2日
+ *
+ * Author: lixingcong
+ */
+
+#ifndef CRYPTO_XOR_H
+#define CRYPTO_XOR_H
+
+#include "crypto.h"
+#include <stdint.h>
+
+int xor_encrypt_all(buffer_t *, cipher_t *, size_t);
+int xor_decrypt_all(buffer_t *, cipher_t *, size_t);
+int xor_encrypt(buffer_t *, cipher_ctx_t *, size_t);
+int xor_decrypt(buffer_t *, cipher_ctx_t *, size_t);
+
+void xor_ctx_init(cipher_t *, cipher_ctx_t *, int);
+void xor_ctx_release(cipher_ctx_t *);
+
+cipher_t *xor_init(const char *pass, const char *key, const char *method);
+
+#endif // CRYPTO_XOR_H
diff --git a/src/crypto.c b/src/crypto.c
index bd544b9..093a6df 100644
--- a/src/crypto.c
+++ b/src/crypto.c
@@ -42,6 +42,7 @@
 #include "aead.h"
 #include "utils.h"
 #include "ppbloom.h"
+#include "crypto-xor.h"
 
 int
 balloc(buffer_t *ptr, size_t capacity)
@@ -192,6 +193,23 @@ crypto_init(const char *password, const char *key, const char *method)
             memcpy(crypto, &temp, sizeof(crypto_t));
             return crypto;
         }
+
+        if (strncmp(method, "xor", 3) == 0) {
+            cipher_t *cipher = xor_init(password, NULL, NULL);
+            crypto_t *crypto = (crypto_t *)ss_malloc(sizeof(crypto_t));
+            crypto_t tmp     = {
+                .cipher      = cipher,
+                .encrypt_all = &xor_encrypt_all,
+                .decrypt_all = &xor_decrypt_all,
+                .encrypt     = &xor_encrypt,
+                .decrypt     = &xor_decrypt,
+                .ctx_init    = &xor_ctx_init,
+                .ctx_release = &xor_ctx_release,
+            };
+            memcpy(crypto, &tmp, sizeof(crypto_t));
+            return crypto;
+        }
+
         for (i = 0; i < STREAM_CIPHER_NUM; i++)
             if (strcmp(method, supported_stream_ciphers[i]) == 0) {
                 m = i;
diff --git a/src/jhash.h b/src/jhash.h
new file mode 100644
index 0000000..bea1009
--- /dev/null
+++ b/src/jhash.h
@@ -0,0 +1,130 @@
+#ifndef _LINUX_JHASH_H
+#define _LINUX_JHASH_H
+
+#include <stdint.h>
+
+/**
+ * rol32 - rotate a 32-bit value left
+ * @word: value to rotate
+ * @shift: bits to roll
+ */
+static inline uint32_t rol32(uint32_t word, unsigned int shift)
+{
+	return (word << shift) | (word >> (32 - shift));
+}
+
+/* jhash.h: Jenkins hash support.
+ *
+ * Copyright (C) 2006. Bob Jenkins (bob_jenkins@burtleburtle.net)
+ *
+ * http://burtleburtle.net/bob/hash/
+ *
+ * These are the credits from Bob's sources:
+ *
+ * lookup3.c, by Bob Jenkins, May 2006, Public Domain.
+ *
+ * These are functions for producing 32-bit hashes for hash table lookup.
+ * hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final()
+ * are externally useful functions.  Routines to test the hash are included
+ * if SELF_TEST is defined.  You can use this free for any purpose.  It's in
+ * the public domain.  It has no warranty.
+ *
+ * Copyright (C) 2009-2010 Jozsef Kadlecsik (kadlec@blackhole.kfki.hu)
+ *
+ * I've modified Bob's hash to be useful in the Linux kernel, and
+ * any bugs present are my fault.
+ * Jozsef
+ */
+
+/* Best hash sizes are of power of two */
+#define jhash_size(n)   ((uint32_t)1<<(n))
+/* Mask the hash value, i.e (value & jhash_mask(n)) instead of (value % n) */
+#define jhash_mask(n)   (jhash_size(n)-1)
+
+/* __jhash_mix -- mix 3 32-bit values reversibly. */
+#define __jhash_mix(a, b, c)			\
+{						\
+	a -= c;  a ^= rol32(c, 4);  c += b;	\
+	b -= a;  b ^= rol32(a, 6);  a += c;	\
+	c -= b;  c ^= rol32(b, 8);  b += a;	\
+	a -= c;  a ^= rol32(c, 16); c += b;	\
+	b -= a;  b ^= rol32(a, 19); a += c;	\
+	c -= b;  c ^= rol32(b, 4);  b += a;	\
+}
+
+/* __jhash_final - final mixing of 3 32-bit values (a,b,c) into c */
+#define __jhash_final(a, b, c)			\
+{						\
+	c ^= b; c -= rol32(b, 14);		\
+	a ^= c; a -= rol32(c, 11);		\
+	b ^= a; b -= rol32(a, 25);		\
+	c ^= b; c -= rol32(b, 16);		\
+	a ^= c; a -= rol32(c, 4);		\
+	b ^= a; b -= rol32(a, 14);		\
+	c ^= b; c -= rol32(b, 24);		\
+}
+
+/* An arbitrary initial parameter */
+#define JHASH_INITVAL		0xdeadbeef
+
+/* jhash2 - hash an array of uint32_t's
+ * @k: the key which must be an array of uint32_t's
+ * @length: the number of uint32_t's in the key
+ * @initval: the previous hash, or an arbitray value
+ *
+ * Returns the hash value of the key.
+ */
+static inline uint32_t jhash2(const uint32_t *k, uint32_t length, uint32_t initval)
+{
+	uint32_t a, b, c;
+
+	/* Set up the internal state */
+	a = b = c = JHASH_INITVAL + (length<<2) + initval;
+
+	/* Handle most of the key */
+	while (length > 3) {
+		a += k[0];
+		b += k[1];
+		c += k[2];
+		__jhash_mix(a, b, c);
+		length -= 3;
+		k += 3;
+	}
+
+	/* Handle the last 3 uint32_t's: all the case statements fall through */
+	switch (length) {
+	case 3: c += k[2];
+	case 2: b += k[1];
+	case 1: a += k[0];
+		__jhash_final(a, b, c);
+	case 0:	/* Nothing left to add */
+		break;
+	}
+
+	return c;
+}
+
+
+/* jhash_3words - hash exactly 3, 2 or 1 word(s) */
+static inline uint32_t jhash_3words(uint32_t a, uint32_t b, uint32_t c, uint32_t initval)
+{
+	a += JHASH_INITVAL;
+	b += JHASH_INITVAL;
+	c += initval;
+
+	__jhash_final(a, b, c);
+
+	return c;
+}
+
+static inline uint32_t jhash_2words(uint32_t a, uint32_t b, uint32_t initval)
+{
+	return jhash_3words(a, b, 0, initval);
+}
+
+static inline uint32_t jhash_1word(uint32_t a, uint32_t initval)
+{
+	return jhash_3words(a, 0, 0, initval);
+}
+
+#endif /* _LINUX_JHASH_H */
diff --git a/src/utils.c b/src/utils.c
index 9241547..f310dcb 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -311,7 +311,7 @@ usage()
     printf(
         "       -k <password>              Password of your remote server.\n");
     printf(
-        "       -m <encrypt_method>        Encrypt method: plain, rc4-md5, \n");
+        "       -m <encrypt_method>        Encrypt method: plain, xor, rc4-md5, \n");
     printf(
         "                                  aes-128-gcm, aes-192-gcm, aes-256-gcm,\n");
     printf(
